# Multithreaded-Network-Server

### Server

This program implements a multithreaded TCP server for managing a simple voting system. It uses a fixed-capacity buffer as a queue to temporarily store client connections, following a first-in, first-out (FIFO) structure. The master thread adds connections to the rear, while worker threads retrieve them from the front. Synchronization is achieved using with mutexes for locking shared resources and condition variables for signaling when the buffer is full or empty. When a SIGINT signal is received, the server writes sorted voting statistics to a file and terminates safely.

## Batch Client

This multi-threaded client program reads votes from an input file and sends them to a server via independent threads. Each thread establishes a TCP connection, sends the voter's details, and receives confirmation. The ThreadData structure stores relevant information, and threads operate independently, ensuring efficient processing and proper memory deallocation. The program exits after handling all votes.

### Bash Scripts

This project also includes 3 bash scripts that were used for debugging purposes.

**Create Input:** <br>


This bash script generates an inputFile.txt containing randomly generated first names, last names, and party affiliations. It takes two arguments: a file with party names and the number of lines to generate. The script validates the input, ensuring the correct number of arguments, the existence and readability of the parties file, a positive integer for the number of lines, and a non-empty parties file. The names generated are random strings between 3 and 12 characters, and parties are randomly selected from the file. A confirmation message is displayed upon successful completion.

**Tally Votes:** <br>

This bash script processes an input file to count votes for each party. It validates the file's existence and readability, sorts its contents, removes duplicates, and ensures each individualâ€™s vote is counted only once. The results are written to a specified output file, with party names listed alphabetically alongside their vote counts. A confirmation message is displayed upon successful completion.

**Process Log File:** <br>

This bash script processes the file generated by the poller.c server, ensuring it exists and is readable. It sorts the file, removes duplicate lines, and counts votes for each party, ensuring only the first vote from each individual is considered. The results are written to a specified output file, with party names listed alphabetically alongside their vote counts. A confirmation message is displayed upon successful completion.

## Usage

1. Before running one of the bash scripts, make it executable:
   ```bash
      chmod +x name_of_bash.sh
   ```
   Replace `name_of_bash` with the name of the script you want to run.
  
2. Run the scripts: <br>

   **Create Input File:**
   ```bash
       ./create_input.sh path_to_parties_file numLines
   ```
     - Replace `path_to_parties_file` with the path to the file containing party names.
     - Replace `numLines` with the number of voters (lines) to generate. <br>
     
   **Tally Votes:**
   ```bash
      ./tallyVotes.sh output_file
   ```
   - Replace `output_file` with the name of the file where voting results will be saved. <br>

   **Process Log File:**
   ```bash
      ./processLogFile.sh output_file
   ```
     - Replace `output_file` with the name of the file where the processed log results will be saved.

Use the Makefile to compile, run and clean up the project using the following commands:

```bash
$ make            # Compile the 'poller' and 'pollSwayer' executables.
$ make run_poller # Execute the 'poller' program with predefined arguments.
$ make run_swayer # Execute the 'pollSwayer' program with predefined arguments.
$ make clean      # Remove object files, executables, and additional files from the directory.
```
! Note: To run the two programs manually, make sure that the first argument of 
        `pollSwayer` is the machine that the 'poller' server is running on.

Please note that this project has been tested and validated on Linux systems.
