// ---------------------- | Problem 1 | ---------------------- //

The server program creates a TCP socket and listens for incoming connections on a specified port. When a new connection is established, the `addToBuffer` function is 
called to add the connection to the buffer. This buffer acts as a communication channel between the master thread and the worker threads, allowing concurrent handling of connections.

The `addToBuffer` function ensures exclusive access to the buffer by acquiring a mutex lock. It checks if there is space available in the buffer. If the buffer is full, 
the thread waits until space becomes available. Once space is available, the connection is added to the buffer by updating the rear index and incrementing the count. 
To notify the waiting worker threads that there is an available connection in the buffer, the 'empty' condition variable is signaled.

When a worker thread needs to retrieve a connection from the buffer to process, it calls the `removeFromBuffer` function. This function also acquires the mutex lock 
to ensure exclusive access to the buffer. It checks if a connection is available in the buffer. If the buffer is empty, the thread waits until it is notified by the 
master thread. Once a connection becomes available, it is retrieved from the front of the buffer by updating the front index and decrementing the count. The 'full' 
condition variable is then signaled to notify the master thread that there is an available slot in the buffer.

Worker threads handle connections by requesting and processing the voter's name and party's name. They check if the voter has already voted by examining the poll-log file. 
If the voter has already voted, the worker thread notifies the client and closes the connection. Otherwise, the worker thread records the vote by requesting the party's name 
from the client. It updates the party's vote count and appends the voter's information to the poll-log file.

To ensure thread safety while updating the party's vote count and accessing the poll-log file, a mutex is used. The mutex ensures that only one thread can access the shared 
resources at a time, preventing data races and inconsistencies.

When the program receives the SIGINT signal (Ctrl+C), the writeStats function is called. This function opens the poll-stats file, sorts the party votes based on the party's 
name in alphabetical order, and writes the sorted party votes and the total votes to the file. Finally, the program exits, and the server shuts down.

// ---------------------- | Problem 2 | ---------------------- //

The multi-threaded client program provided establishes a connection to a server to send votes. It reads votes from the input file given as an argument. 
For each vote, the program creates a new thread dedicated to sending the vote to the server and receiving confirmation messages. The necessary data for each thread is stored in a 
structure called `ThreadData`, which includes the server name, port number, voter's name, surname, and the vote they cast. The threads establish independent TCP socket connections 
with the server using address resolution with the help of `sendVote` function. These threads operate independently and detach from the main thread. Once all the votes have been processed, 
the program gracefully exits, ensuring proper memory deallocation.

// ---------------------- | Problem 3 | ---------------------- //

/* ===== create_input.sh ===== */
This bash script generates a file called inputFile.txt that includes names, surnames, and the party that each person voted for. It expects two arguments: 
a file containing the names of parties and the number of lines to generate. The script performs various checks, such as ensuring that the correct number of arguments is provided, 
verifying the existence of the parties file, checking if numLines is a positive integer, and ensuring that the parties file is not empty. It then randomly selects parties from the 
parties file and generates random strings as first names and last names. The length of each first name and last name ranges between 3 and 12 characters. Finally, the script 
prints a message indicating that the file has been successfully created.

/* ====== tallyVotes.sh ====== */
This bash script checks if an input file exists and has appropriate permissions. It proceeds to sort the file, remove duplicate lines, and count the votes for each party.
The script also ensures that only the first vote from each individual is counted, disregarding any subsequent votes from the same person. It then creates a file named tallyResultsFile, 
where the votes for each party are stored in alphabetical order based on the party's name. Finally, it prints a message indicating that the results have been written to the file.

/* ==== processLogFile.sh ==== */
This bash script checks if the file generated by running the poller.c (server) exists and has appropriate permissions. 
It proceeds to sort the file, remove duplicate lines, and count the votes for each party. The script also ensures that only the first vote from 
each individual is counted, disregarding any subsequent votes from the same person. It then creates a file named pollerResultsFile, 
where the results are stored in alphabetical order based on the party's name. Finally, it prints a message indicating that the results have been written to the file.

Usage:
1. Change permissions: `chmod +x name_of_bash.sh`
   - Where `name_of_bash` is the name of the bash script you want to execute.

2. Run the script:
- `./create_input.sh path_to_parties_file numLines`
        - `path_to_parties_file` is the path to the file containing party names.
        - `numLines` is the number of voters (lines) you want to generate.
- `./tallyVotes.sh output_file`
        - `output_file` is the name of the file where the voting results will be written.
- `./processLogFile.sh output_file`
        - `output_file` is the name of the file where the processed log results will be written.

// ====================== | Makefile | ====================== //

To use the provided Makefile, follow these commands:

- make: Compile the 'poller' and 'pollSwayer' executables.
- make run_poller: Execute the 'poller' program with predefined arguments.
- make run_swayer: Execute the 'pollSwayer' program with predefined arguments.
- make clean: Remove object files, executables, and additional files from the directory.

! Note: If you want to run the two programs manually, make sure that the first argument of 
        `pollSwayer` is the machine that the 'poller' server is running on.